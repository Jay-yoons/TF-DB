# 🕐 개선된 예약 시스템 스키마 (시간대별 관리)

## 📋 현재 문제점 분석

### 기존 스키마의 한계
```sql
-- 현재 BOOKING 테이블 (문제점)
CREATE TABLE BOOKING (
    BOOKING_NUM VARCHAR2(20) PRIMARY KEY,
    BOOKING_DATE DATE NOT NULL,        -- ❌ 시간 정보 없음
    USER_ID VARCHAR2(15) NOT NULL,
    STORE_ID VARCHAR2(20) NOT NULL,
    BOOKING_STATE_CODE VARCHAR2(10) NOT NULL,
    COUNT NUMBER NOT NULL
);
```

### 발생 가능한 문제들
1. **같은 날짜에 모든 예약이 겹침**
2. **시간대별 좌석 관리 불가능**
3. **실제 레스토랑 운영과 맞지 않음**
4. **예약 몰림 상황 시뮬레이션 어려움**

## 🏗️ 개선된 스키마 제안

### 1. 개선된 BOOKING 테이블
```sql
CREATE TABLE BOOKING (
    BOOKING_NUM VARCHAR2(20) PRIMARY KEY,
    BOOKING_DATE DATE NOT NULL,
    BOOKING_TIME VARCHAR2(5) NOT NULL,     -- 추가: 시간 (예: "18:30")
    BOOKING_DATETIME TIMESTAMP NOT NULL,   -- 추가: 날짜+시간 조합
    USER_ID VARCHAR2(15) NOT NULL,
    STORE_ID VARCHAR2(20) NOT NULL,
    BOOKING_STATE_CODE VARCHAR2(10) NOT NULL,
    COUNT NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP
);

-- 인덱스 추가
CREATE INDEX idx_booking_datetime ON BOOKING(BOOKING_DATETIME);
CREATE INDEX idx_booking_store_time ON BOOKING(STORE_ID, BOOKING_DATE, BOOKING_TIME);
CREATE UNIQUE INDEX idx_booking_unique ON BOOKING(STORE_ID, BOOKING_DATE, BOOKING_TIME, USER_ID);
```

### 2. 시간대별 좌석 관리 테이블
```sql
CREATE TABLE STORE_TIME_SLOT (
    SLOT_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    STORE_ID VARCHAR2(20) NOT NULL,
    BOOKING_DATE DATE NOT NULL,
    TIME_SLOT VARCHAR2(5) NOT NULL,        -- 시간대 (예: "18:00", "18:30", "19:00")
    MAX_CAPACITY NUMBER NOT NULL,          -- 해당 시간대 최대 수용 인원
    CURRENT_BOOKINGS NUMBER DEFAULT 0,     -- 현재 예약된 인원
    AVAILABLE_SEATS NUMBER GENERATED ALWAYS AS (MAX_CAPACITY - CURRENT_BOOKINGS) VIRTUAL,
    IS_ACTIVE NUMBER(1) DEFAULT 1,         -- 시간대 활성화 여부
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP,
    
    CONSTRAINT uk_store_time_slot UNIQUE (STORE_ID, BOOKING_DATE, TIME_SLOT)
);

-- 인덱스
CREATE INDEX idx_time_slot_store_date ON STORE_TIME_SLOT(STORE_ID, BOOKING_DATE);
CREATE INDEX idx_time_slot_available ON STORE_TIME_SLOT(STORE_ID, BOOKING_DATE, AVAILABLE_SEATS);
```

### 3. 가게 운영 시간 테이블
```sql
CREATE TABLE STORE_OPERATING_HOURS (
    HOUR_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    STORE_ID VARCHAR2(20) NOT NULL,
    DAY_OF_WEEK NUMBER(1) NOT NULL,        -- 1=월요일, 7=일요일
    OPEN_TIME VARCHAR2(5) NOT NULL,        -- 오픈 시간 (예: "11:00")
    CLOSE_TIME VARCHAR2(5) NOT NULL,       -- 마감 시간 (예: "22:00")
    TIME_SLOT_INTERVAL NUMBER DEFAULT 30,  -- 예약 시간 간격 (분)
    IS_ACTIVE NUMBER(1) DEFAULT 1,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    
    CONSTRAINT uk_store_day_hours UNIQUE (STORE_ID, DAY_OF_WEEK)
);

-- 인덱스
CREATE INDEX idx_operating_hours_store ON STORE_OPERATING_HOURS(STORE_ID, DAY_OF_WEEK);
```

### 4. 대기열 관리 테이블
```sql
CREATE TABLE BOOKING_QUEUE (
    QUEUE_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    STORE_ID VARCHAR2(20) NOT NULL,
    BOOKING_DATE DATE NOT NULL,
    TIME_SLOT VARCHAR2(5) NOT NULL,
    USER_ID VARCHAR2(15) NOT NULL,
    QUEUE_POSITION NUMBER NOT NULL,        -- 대기열 순서
    REQUESTED_COUNT NUMBER NOT NULL,       -- 요청한 인원 수
    QUEUE_STATUS VARCHAR2(20) DEFAULT 'WAITING', -- WAITING, PROCESSING, COMPLETED, CANCELLED
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP,
    
    CONSTRAINT uk_queue_position UNIQUE (STORE_ID, BOOKING_DATE, TIME_SLOT, QUEUE_POSITION)
);

-- 인덱스
CREATE INDEX idx_queue_store_time ON BOOKING_QUEUE(STORE_ID, BOOKING_DATE, TIME_SLOT);
CREATE INDEX idx_queue_status ON BOOKING_QUEUE(QUEUE_STATUS);
```

## 🔄 예약 몰림 시나리오 분석

### 시나리오 1: 특정 시간대 몰림
```sql
-- 예시: 2024-01-20 18:30 시간대에 100명이 동시 예약 시도
-- STORE_TIME_SLOT 테이블에서 해당 시간대 좌석 확인
SELECT * FROM STORE_TIME_SLOT 
WHERE STORE_ID = 'store001' 
  AND BOOKING_DATE = DATE '2024-01-20' 
  AND TIME_SLOT = '18:30';

-- 결과: MAX_CAPACITY = 50, CURRENT_BOOKINGS = 0
-- 100명 중 50명만 예약 가능, 나머지 50명은 대기열로
```

### 시나리오 2: 인기 시간대 몰림
```sql
-- 예시: 저녁 시간대 (18:00-20:00) 전체 몰림
SELECT TIME_SLOT, MAX_CAPACITY, CURRENT_BOOKINGS, AVAILABLE_SEATS
FROM STORE_TIME_SLOT 
WHERE STORE_ID = 'store001' 
  AND BOOKING_DATE = DATE '2024-01-20' 
  AND TIME_SLOT IN ('18:00', '18:30', '19:00', '19:30', '20:00')
ORDER BY TIME_SLOT;
```

### 시나리오 3: 특정 날짜 몰림
```sql
-- 예시: 주말이나 특별한 날 전체 몰림
SELECT BOOKING_DATE, TIME_SLOT, 
       SUM(CURRENT_BOOKINGS) as TOTAL_BOOKINGS,
       SUM(MAX_CAPACITY) as TOTAL_CAPACITY
FROM STORE_TIME_SLOT 
WHERE STORE_ID = 'store001' 
  AND BOOKING_DATE BETWEEN DATE '2024-01-20' AND DATE '2024-01-21'
GROUP BY BOOKING_DATE, TIME_SLOT
ORDER BY BOOKING_DATE, TIME_SLOT;
```

## 🧪 개선된 테스트 시나리오

### 1. 시간대별 몰림 테스트
```http
### 특정 시간대 몰림 테스트 (18:30)
POST {{baseUrl}}/api/bookings
Content-Type: {{contentType}}
Authorization: Bearer {{accessToken}}

{
  "userId": "user001",
  "storeId": "store001",
  "bookingDate": "2024-01-20",
  "bookingTime": "18:30",
  "count": 4
}
```

### 2. 동시 예약 테스트 (Race Condition)
```bash
# 100명이 동시에 18:30 시간대 예약 시도
for i in {1..100}; do
  curl -X POST "https://reservation-service.team-fog.com/api/bookings" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -d "{
      \"userId\": \"user$i\",
      \"storeId\": \"store001\",
      \"bookingDate\": \"2024-01-20\",
      \"bookingTime\": \"18:30\",
      \"count\": 2
    }" &
done
wait
```

### 3. 대기열 처리 테스트
```http
### 대기열 상태 확인
GET {{baseUrl}}/api/bookings/queue/store001/2024-01-20/18:30
Authorization: Bearer {{accessToken}}

### 대기열에서 예약으로 전환
POST {{baseUrl}}/api/bookings/queue/process
Content-Type: {{contentType}}
Authorization: Bearer {{accessToken}}

{
  "storeId": "store001",
  "bookingDate": "2024-01-20",
  "timeSlot": "18:30",
  "queuePosition": 1
}
```

## 🏗️ 인프라 해결책 (개선된 버전)

### 1. 시간대별 자동 스케일링
```json
{
  "scheduledActions": {
    "lunchTimeScaling": {
      "scheduledActionName": "lunch-time-scaling",
      "schedule": "cron(0 11 * * ? *)",
      "scalableTargetAction": {
        "minCapacity": 3,
        "maxCapacity": 15
      }
    },
    "dinnerTimeScaling": {
      "scheduledActionName": "dinner-time-scaling", 
      "schedule": "cron(0 17 * * ? *)",
      "scalableTargetAction": {
        "minCapacity": 5,
        "maxCapacity": 25
      }
    }
  }
}
```

### 2. 시간대별 캐싱 전략
```java
// Redis 캐시 키 구조
String cacheKey = String.format("booking:store:%s:date:%s:time:%s", 
    storeId, bookingDate, timeSlot);

// 시간대별 예약 현황 캐싱
@Cacheable(value = "bookingSlots", key = "#cacheKey")
public TimeSlotAvailability getTimeSlotAvailability(String storeId, 
                                                   LocalDate date, 
                                                   String timeSlot) {
    // 데이터베이스 조회
}
```

### 3. 대기열 처리 시스템
```java
@Service
public class BookingQueueService {
    
    @Async
    public CompletableFuture<BookingResult> processQueue(String storeId, 
                                                        LocalDate date, 
                                                        String timeSlot) {
        // 대기열에서 순서대로 예약 처리
        // 좌석이 확보되면 자동으로 예약 완료
    }
}
```

## 📊 모니터링 지표 (개선된 버전)

### 1. 시간대별 예약 현황
```sql
-- 시간대별 예약률
SELECT TIME_SLOT, 
       ROUND(CURRENT_BOOKINGS / MAX_CAPACITY * 100, 2) as BOOKING_RATE,
       CURRENT_BOOKINGS,
       MAX_CAPACITY,
       AVAILABLE_SEATS
FROM STORE_TIME_SLOT 
WHERE STORE_ID = 'store001' 
  AND BOOKING_DATE = DATE '2024-01-20'
ORDER BY TIME_SLOT;
```

### 2. 대기열 통계
```sql
-- 시간대별 대기열 현황
SELECT TIME_SLOT,
       COUNT(*) as QUEUE_LENGTH,
       AVG(QUEUE_POSITION) as AVG_WAIT_POSITION,
       MAX(QUEUE_POSITION) as MAX_WAIT_POSITION
FROM BOOKING_QUEUE 
WHERE STORE_ID = 'store001' 
  AND BOOKING_DATE = DATE '2024-01-20'
  AND QUEUE_STATUS = 'WAITING'
GROUP BY TIME_SLOT
ORDER BY TIME_SLOT;
```

## 🎯 결론

### 기존 스키마의 한계
- ❌ 시간대별 예약 관리 불가능
- ❌ 실제 레스토랑 운영과 맞지 않음
- ❌ 예약 몰림 상황 시뮬레이션 어려움

### 개선된 스키마의 장점
- ✅ 시간대별 세밀한 예약 관리
- ✅ 실제 레스토랑 운영과 일치
- ✅ 다양한 몰림 시나리오 테스트 가능
- ✅ 대기열 시스템으로 사용자 경험 개선
- ✅ 시간대별 자동 스케일링 가능

이제 **특정 시간대에 인원이 몰리는 상황**을 정확하게 시뮬레이션하고 테스트할 수 있습니다! 🚀
